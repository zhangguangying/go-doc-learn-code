# Go 语言精进之路：从新手到高手的编程思想、方法和技巧

## 三、声明、类型、语句与控制结构

### 8. 保持声明的一致性

包级变量 ：只能通过 var 进行声明

- 声明并初始化推荐方式 ：var s = '123' , 如果要指定类型，推荐这么写 ：var s = string('123')

- 声明延迟初始化 ：var s string

- 声明聚类 ：通过 var 将相同类型的变量放在一块声明

局部变量 

- 比包级变量多了短变量声明的方式 

- 对于延迟初始化的变量，采用 var 的方式声明，对于声明且显式初始化的变量，使用短变量声明

### 9. 使用无类型常量简化代码

const 关键字声明常量，常量需要是整型、浮点型、字符串、字符型字面量
**Go 在处理不同类型的变量间的运算时，不支持隐式类型转换**。
**如果常量显式声明了类型，那么也不可以直接跟不同类型的变量进行运算。但是无类型的常量可以进行不同类型的变量赋值与运算**。
const 语法提供了“**隐式重复前一个非空表达式**”的机制，常量定义的后面的行如果没有显式给予初始赋值，Go 编译器将为其隐式使用前面最近一行的赋值。

### 10. 使用 iota 枚举常量

iota 是 Go 语言的一个预定义标识符，<mark>**表示在 const 声明块中，每一行在块中的偏移量**</mark>，从 0 开始。它与上面的特性“隐式重复前一个非空表达式”结合，可以灵活定义任意的常量值。
可以通过 _ 让 iota 空加 ，得到自己想要的顺序

### 11. 尽量定义零值可用的类型

当通过声明或调用 new 为变量分配存储空间，或者通过复合文字字面量或调用 make 创建新值，且不提供显式初始化时，Go 会为变量或值提供默认值。
Go语言的每个原生类型都有默认值，这个默认值就是这个类型的零值：

- 所有整型类型：0

- 浮点类型：0.0

- 布尔类型：false

- 字符串类型：""

- 指针、interface、切片（slice）、channel、map、function：nil

**<mark>零值可用就是对于只声明未初始化的类型，我们也可以使用该类型对应的方法，完成我们想要的操作</mark>**。零值可用给我们日常开发带来了很多便利，我们自定义类型时应尽量保证零值可用。

### 12. 使用复合字面值作为初值构造器

复合字面值由两部分组成，一部分是类型，一部分是大括号 {} 包起来的字面值。
对于零值不适用的场景，要为变量赋予一定的初值。对于复合类型，我们应该首选 Go 提供的复合字面值作为初值构造器。

### 13. 了解切片实现原理并高效使用

切片的底层是数组，切片的数据结构中只是保存了一个指向底层数组的指针。cap 表示切片的最大容量，我的理解是通过 append 插入元素的时候，超过这个容量会扩容。len 表示切片的长度，也就是可以通过下标访问的长度。

日常工作中建立通过 make 创建切片的时候，传入合适的容量参数，因为每次扩容都需要重新创建一个更大的数组，并把老数组的数据复制过去，这个代码还是很大的。

### 14. 了解 map 实现原理并高效使用

map 是一组无序的键值对，它要求 key 值必须是可以通过 "==" 和 "!=" 比较的。map 和切片一样，是引用类型，在函数内部的修改会影响到外部。可以通过复合字面值和 make 创建 map 。map 不是零值可用的。

**map 的基本操作**

- 插入 ：通过键名设置 ，m[k] = v

- 获取数据个数 ：len(m)

- 查找和数据读取 ：要始终使用 comma ok 语法读取数据 ，v, ok := m[k] ，因为读取不存在的键名时，map 会返回 value 的零值，我们无法判断值到底存不存在。

- 删除数据 ：delete(m, k)

- 遍历数据 ：for k, v range m ，map 的遍历是无序的，如果想要遍历有序，可以将 key 放入切片，对切片排序，通过遍历切片，来得到 map 的值。


